# Node.js 1장장

# 1-1

## 런타임
- Node.js는 Chrome V8 Javascript엔진으로 빌드된 자바스크립트 런타임
- V8과 libuv 라이브러리 사용
    - libuv 라이브러리 -> 이벤트 기반, 논블로킹 I/O 모델

## 이벤트 기반
- 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 것
- 이벤트 리스너에 콜백 함수 등록해야 함
- 이벤트 루프 : 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할 지를 판단

```javascript
    function run(){
        console.log('3초 후 실행');
    }
    console.log('시작');
    setTimeout(run, 3000);
    console.log('끝');
```
- 이 코드에선 '시작, 끝, 3초후 실행' 순서로 결과값이 찍힐 것
- 작동과정
    - anonymous가 호출 스택으로 들어감
    - setTimeout이 호출 스택으로 들어감
    - setTimeout이 먼저 실행
    - 타이머와 함께 run콜백을 백그라운드로 보내고 setTimeout은 호출스택에서 빠짐
    - anonymous가 호출 스택에서 빠짐
    - 백그라운드에서는 3초를 센후 run함수를 태스크 큐로 보냄
- setTimeout의 시간이 부정확할 수 있는 이유?
    - 호출 스택에 함수가 너무 많이 들어있는 경우 설정한 초가 지난 후에도 함수가 실행 안될 수 있음
    - 이벤트 루프는 호출 스택이 비어 있을 때 태스크 큐에 있는 함수를 호출 스택으로 가져오기 때문


## 논블로킹 I/O

### 정의 
- 논블로킹: 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행하는 것
- 블로킹: 이전 작업이 끝나야만 다음 직업을 수행하는 것
- I/O: 입력, 출력을 의미하며 파일 시스템 접근(파일 읽기 및 쓰기, 폴더 만들기 등) 이나 네트워크를 통한 요청 같은 작업

### 작업
- 블로킹과 논블로킹 방식 중 같은 작업을 처리할 때 논블로킹이 더 잛은 시간에 처리(단, 동시에 처리될 수 있는 작업이 있다는 전제 하에)

```javascript
    function longRunningTask(){
        console.log('작업 끝');
    }
    console.log('시작');
    setTimeout(longRunningTask, 0);
    console.log('다음 작업');
```
- '시작, 다음 작업, 작업 끝' 순서로 콘솔 창에 결과값 찍힘
- setTimeout의 콜백함수인 longRunningTask가 태스크 큐로 보내져 순서대로 실행되지 않음.. 다음 작업이 먼저 실행된 후, 오래 걸리는 작업이 완료됨
- 하지만, 우리가 작성한 코드라면 저체 소요 시간이 짧아지지 않음. 우리가 작성한 코드가 동시에 실행되지 않기에...
- 그렇다고해도 의미가 없는 거 아님. 오래 걸리는 작업 경우 논블로킹으로 실행 순서 바꿔줄 수 있음

#### 논블로킹으로 만드는 방법
- setTimeout(콜백함수, 0)
- setImmediate(3.4.3절에서 자세히)

## 싱글 스레드
- 스레드가 하나뿐이라는 것을 의미 (우리가 작성하는 코드가 동시실행이 불가한 이유)
- 노드는 엄밀히 말하면 싱글 스레드로 동작하지 x
    - 노드 실행하면 먼저 프로세스가 하나 생성
    - 프로세스에서 스레드들을 생성
    - 이 스레드들중에서 우리가 직접 제어할 수 있는 스레드가 하나라서 노드가 싱글 스레드로 불림

### 프로세스와 스레드의 차이
- 프로세스: 운영세제에서 할당하는 작업의 단위
    - 노드, 웹브라우저는 개별적인 프로세스
    - 프로세스 간에 메모리 자원 공유x

- 스레드: 프로세스 내에서 실행되는 흐름의 단위
    - 프로세스 내에서 스레드가 여러개 생성되어 여러 작업이 동시에 처리 가능
    - 스레드는 부모 프로세스의 자원을 공유
    - 같은 주소의 메모리에 접근 가능 -> 데이터 공유 가능

### 멀티 스레드가 더 좋을까?
- 간단히 말하면 반드시 더 좋다고 할 수 없다.

### 멀티 스레딩과 멀티 스로세싱 비교
- 멀티스레딩
    - 하나의 프로세스 안에서 여러 개의 스레드 사용
    - CPU작업이 많이 사용될 때 사용
    - 프로그래밍이 어려움
- 멀티 프로세싱
    - 여러 개의 프로세스 사용
    - I/O 요청이 많을 때 사용
    - 비교적 쉬움

# 1-2 서버로서의 노드
- 서버는 기본적으로 I/O 요청이 많이 발생해 I/O 처리를 잘하는 노드를 서버로 사용하면 좋음
- libuv 라이브러리를 사용해 I/O 작업을 논블로킹 방식으로 처리 (논블로킹 방식으로 코드 작성 가정 시)
- 스레드 하나가 많은 수의 I/O를 혼자서 감당할 수 있으나 CPU 부하가 큰 작업엔 부적합

## 노드를 사용하면 좋은 곳
- 개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는 곳
- 네트워크나 데이터베이스, 디스크 작업 같은 I/O에 특화되어 있음
- ex. 실시간 채팅 애플리케이션이나 주식 차트, JSON 데이터를 제공하는 API 서버

## 노드의 장점
- 웹 서버가 내정되어 있어 입문자가 쉽게 접근 가능
- 자바스크립트를 언어로 사용함
- 웹 브라우저도 자바스크립트를 사용하기에 서버까지 노드로 사용하면 하나의 언어로 웹사이트 개발 가능 => 개발 생산성 증가, 생산성 중요한 기업이 채택
- 요즘은 XML 대신 JSON을 사용해서 데이터를 주고 받는데 JSON이 자바스크립트 방식

# 1-3 서버외의 노드
- 처음에는 서버로서만 사용했으나 사용범위가 늘어나 웹, 모바일, 애플리케이션 개발에도 사용
- 웹 프레임워크: 앵귤러(angular), 리액트(react), 뷰(vue)
    - 앵귤러: 구글 진영에서 프런트엔드 앱 만들 때 사용
    - 리액트: 페이스북 진영에서 주로사용
- 모바일 앱: 리액트 네이티브(react native)
    -페이스북, 인스타그램 핀터레스트, 월마트, 테슬라
- 데스크톱: 일렉트론(electron)
    - Atom, Slack, Discord


